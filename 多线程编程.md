####基础概念  
多线程模型允许同一时间有多个处理单元执行统一进程中的代码，而通过分离的栈空间和共享的数据区及堆栈空间，线程可以拥有独立状态及进行快速的数据共享。  
  
####多线程模型的实现方式  
1，posix标准库的API pthread。   
2，OpenMP编译器指令。使用的便利性上1不如2。


####关键词  
1，原子操作：多线程中“最小的不可并行化的”操作。编译器可以保证原子类型的变量在多线程之间被互斥访问。  
2，互斥：原子操作通常都是通过“互斥的访问”来保证的。  
3，临界区：即需要保持原子操作的部分。  
4，内存模型：即cpu访问内存的顺序。

  
####互斥访问的实现方式：  
1，实现互斥通常需要平台相关特殊的指令，c++11之前是通过内嵌汇编代码实现的。  
2，实现粗粒度的互斥，可以使用posix标志的pthread库中的互斥锁（mutex）。

####原子性的实现方式  
（1）处理器提供的指令。  
（2）加锁。


####疑问  
1，c++中的线程的实现，是不是对unix或windows系统底层的线程库的封装？  
2，在一个进程中，分离的占空间是怎样实现的？  
3，硬件是怎么实现互斥的？  
4，c++11的atomic底层是使用的汇编实现的，不是posix提供的库，c++11的mutex是对操作系统底层的API的封装。  
5，  



 
 
c++11中的atomic类型变量的实现方式：
（1）处理器提供的指令。
（2）加锁的方式。
注：对于整型量和指针等简单类型，通常结果是无锁的原子对象；而对于另外一些类型，比如 64 位机器上大小不是 1、2、4、8（有些平台 / 编译器也支持对更大的数据进行无锁原子操作）的类型，编译器会自动为这些原子对象的操作加上锁。

c++11中的atomic首先保证了类型的原子性操作，而且也是可以指定内存的访问顺序，原子类型在操作的时候，是可传一个内存访问顺序参数的。  


  
额外扩展：
1，编译器是根处理器的平台相关的（arm架构arm的gcc，x86有x86的gcc），不同的处理器平台，会对应不同的汇编指令集，编译器就是针对不同的指令集，把源码编译出不同的汇编代码，跑在对应的处理器上。


