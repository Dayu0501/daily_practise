编译器给的默认构造函数的作用：
1，调用基类的构造函数。
2，调用非static成员变量的构造函数。

编译器产生的默认的函数的默认的版本，都是public和inline的。
默认的拷贝构造，使用的是一个一个位的拷贝。
父类的析构函数应该是虚函数。
如果没有特殊操作的话，只是简单的赋值编译器提供默认的拷贝构造函数就可以满足了。不管哪种的构造函数，如果自己定义了，编译器就不会生成默认的构造函数，
如果没有自己定义拷贝构造函数的话，编译器还是会提供默认版本的拷贝构造函数的。
单例模式不准许拷贝构造和拷贝赋值。
private-copy开放给了友元函数或者友元类。
boost中存在这样的类，基类为不能copy或者是private-copy的，继承他们的子类，也就有这样的性质了。
当子类继承nocopy这样的类的时候，当调用子类的copy构造的时候，子类的copy构造需要调用基类的copy构造初始化基类的部分，因为基类的是nocopy的，所以
调用基类失败，所以该子类的copy constructor也是失败的，copy assign也是同样的道理。
